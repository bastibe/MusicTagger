\section{Distance}
\label{sec:Distance}
In order to measure the similarity of different samples, the Dynamic Time Warping (DTW) algorithm was used. DTW compares sequences of feature vectors to one another, even if the sequences are of different lengths. This is important, since the samples in our sample base have different lengths. DTW stretches and compresses sample feature vector sequences for maximum similarity. It can thus find similarities in samples that are time-stretched versions of one another or that contain each other.\\
DTW first compares every feature vector of one sample to every feature vector of another sample by calculating the Euclidean distance between each feature vector. This creates a cost matrix $C$ of distances between every block of the first sample to every block of the second sample. This matrix is of dimension $N \times M$, where $N$ and $M$ are the lengths of the feature sequences of both samples, respectively.\\
Then, DTW searches for the cheapest path through $C$. In order to not evaluate every possible path through this matrix, DTW only calculates the cheapest path for every positive time step from $C_{n-1,m}, C_{n,m-1}, C_{n-1,m-1}$ to $C_{n,m}$. The final distance between the samples is then calculated by adding all the steps $C_{n.m}$ on the cheapest paths from $C_{0,0}$ to $C_{N,M}$. Additionally, every step is multiplied by $\frac{1}{N}$ or $\frac{1}{M}$ or $||(\frac{1}{N},\frac{1}{M})||$ to correct for the stepping distance through the cost matrix.\\
This algorithm was implemented in Python, but it was too slow for practical comparisons of big sample sets. Thus, we further implemented it in C and called that version from Python, which provided two orders of magnitude of speedup. Still, calculating all the distances between all the samples in the sample database takes about two hours on a modern computer\footnote{Four times longer on Windows}. This distance matrix was saved as Pandas DataFrame to a HD5 database of 60~Mb.